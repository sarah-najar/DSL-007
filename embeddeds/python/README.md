This directory contains an embedded Python DSL for ArduinoML. It now covers the basic scenarios and several extensions from `docs/DSL_LAB.md` while aligning with the domain model shown in `docs/DSL_MDL.png` (states with entry actions, conditional and temporal transitions, digital and analog bricks, buzzer and LCD actions).

Quick start (methodâ€‘chaining DSL)
1) Open a Python shell from `embeddeds/python`
2) Generate Wiring code by printing one of the examples in `embeddeds/python/examples`:

   - `python -c "from examples.Alarm import app; print(app())"`
   - `python -c "from examples.TwoButtonsAnd import app; print(app())"`
   - `python -c "from examples.StateSwitch import app; print(app())"`
   - `python -c "from examples.MultiState import app; print(app())"`
   - `python -c "from examples.TemporalAfterPush import app; print(app())"`
   - `python -c "from examples.TimerBlink import app; print(app())"`
   - `python -c "from examples.Beeps import app; print(app())"`
   - `python -c "from examples.LCD_OK import app; print(app())"`
   - `python -c "from examples.PotOnly import app; print(app())"`
   - `python -c "from examples.DualButtonAndPot import app; print(app())"`

The resulting Arduino code is similar to the kernel generator output. Example for the toggle:

```c
// generated by ArduinoML

int BUTTON = 9;
int LED = 12;

void setup() {
	pinMode(BUTTON, INPUT);
	pinMode(LED, OUTPUT);
}

int state = LOW; int prev = HIGH;
long time = 0; long debounce = 200;

void state_off() {
	digitalWrite(LED, LOW);
	boolean guard =  millis() - time > debounce;
	if (digitalRead(BUTTON) == HIGH && guard) {
		time = millis(); state_on();
	} else {
		state_off();
	}
}

void state_on() {
	digitalWrite(LED, HIGH);
	boolean guard =  millis() - time > debounce;
	if (digitalRead(BUTTON) == HIGH && guard) {
		time = millis(); state_off();
	} else {
		state_on();
	}
}

void loop() { state_off(); }
```

DSL options:

- [No DSL](#nodsl) for reference

- [DSL with Builder+MethodChaining Patterns](#methodchaining)
 
## <a name="nodsl">No DSL</a>

The direct use of the model in Python is quite verbose.

```python
[... imports ...]

button = Sensor("BUTTON", 9)
led = Actuator("LED", 12)

on = State("on", [Action(HIGH, led)])
off = State("off", [Action(LOW, led)])

switchon = Transition(button, HIGH, on)
switchoff = Transition(button, HIGH, off)

on.settransition(switchoff)
off.settransition(switchon)

app = App("Switch!", [button, led], [off, on])

print app
```

In a shell:

1. go to the `embeddeds/python` directory
2. run the python interpreter, `python`, and type:


	```bash
	>>> from pyArduinoML.model.Main import demo
	>>> demo()
	```
	
3. alternatively to 2 you can run directly:

	```bash
	python -m pyArduinoML.model.Main
	```

## <a name="methodchaining">DSL with Builder+MethodChaining Patterns</a>

The extended DSL provides:
- Bricks: `sensor("b").on_pin(2)`, `actuator("led").on_pin(12)`, `buzzer("bz").on_pin(8)`, `lcd("screen").size(16,2)`, `potentiometer("pot").on(0)`
- States and entry actions: `.state("idle").set("led").to(LOW)`, `.set("bz").shortBeep()`, `.set("screen").display("HELLO")`
- Transitions: `.when("b1").becomes(HIGH).go_to_state("on")`, `.after(800).go_to_state("off")`
- Helpers for composite conditions: `.whenBothHigh("b1","b2")`, `.whenPotAtLeast("pot",600)`, `.whenPotBelow("pot",600)`, `.whenButtonAndPotAtLeast("b1","pot",512)`, `.whenEitherButtonLowOrPotBelow("b1","pot",512)`
- Initial state: `.initial("idle")`

```python
[... imports ...]

app = AppBuilder("Switch!") \
    .sensor("BUTTON").on_pin(9) \
    .actuator("LED").on_pin(12) \
    .state("off") \
        .set("LED").to(LOW) \
        .when("BUTTON").has_value(HIGH).go_to_state("on") \
    .state("on") \
        .set("LED").to(HIGH) \
        .when("BUTTON").has_value(HIGH).go_to_state("off") \
    .get_contents()

print app
```

A slight variation is to use python `eval` construct to avoid some syntactic sugar (line breaks).

```python
[... imports ...]

app2 = AppStringBuilder("""
AppBuilder("Switch!")
    .sensor("BUTTON").on_pin(9)
    .actuator("LED").on_pin(12)
    .state("off")
        .set("LED").to(LOW)
        .when("BUTTON").has_value(HIGH).go_to_state("on")
    .state("on")
        .set("LED").to(HIGH)
        .when("BUTTON").has_value(HIGH).go_to_state("off")
""")

print app2
```

Or course, there, you loose auto-completion (which is anyway limited in IDEs for python due to the typing mechanisms)

In a shell:

1. go to the `embeddeds/python` directory
2. run the python interpreter, `python`, and type:


	```bash
	>>> from pyArduinoML.methodchaining.Main import *
	>>> demo1() # for the first example
	>>> demo2() # for the variation
	```
	
3. alternatively to 2 you can run directly:

	```bash
	python -m pyArduinoML.methodchaining.Main
	```
